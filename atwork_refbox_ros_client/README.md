# Refere box client

In the atwork_refbox_ros_client directory the launch file is in the subdirectory of atwork_refbox_ros_client/ros/launch and the different nodes are in the subdirectory atwork_refbox_ros_client/ros/src.

The Referee box client package is a github that provides a kind of starting kit or toolbox to create a system interacting with the referee box and the robot. The referee box is an application developped specifically by the competition organisation to send the tasks of the robots taking part in the competition. This application can be cloned from the github: https://github.com/industrial-robotics/atwork_central_factory_hub. The referee box allows communication between operators connected to the same network. The type of communication that it uses are the protocol buffers, which are the Google platform and language independent mechanism for serializing structured data. The github of the referee box client can be cloned in the source directory: https://github.com/industrial-robotics/atwork_refbox_ros_client. The packages provides a 2 nodes: a cpp script that gets the protocol buffers of the referee box on the server and translates to ros messages and publishes then in several topics. The second node a cpp script with one function, sending the beacon signal of the robot.

The implementation made on the referee box communication is set of 3 nodes written in cpp and a launch file connected to the robot_example_ros node, the one from the referee box client, in the following structure pictured in the rqt graph.
![alt text](https://github.com/Youbotfontysatwork/youbot_fontys/blob/master/atwork_refbox_ros_client/rqt.png)
The three nodes are the logging_node, a publisher sending a boolean to the robot_example_ros node transmitting to the referee box that the robot is in fact logging to send the tasks. The inventory_sender is subscribed to the robot_example_node to get the competition messages data of the items to be picked and publishes them as string data. Finally the task_sender is also subscribed to the to the robot_example_ros to get the data of the locations the robot has to go. From the ros parameters in transforms the positions in geometry pose data to publish it.

## Referee box client Logging node:

This node is a publisher sending the information that the robot logging. The type of message is specific to this competition it is an atwork_ros_msgs::LoggingStatus. This type of message is the type supported by the topic to which it publishes /robot_example_ros/logging_status. The include files of the atwork_ros_msgs is provided by the referee box ros communication package. This node is made of one main loop, where all the Ros functions are called to declare the components of a ros publisher. Further, the while loop is responsible for publishing the msg which is a boolean set on True, meaning that the robot is in fact logging as shown in the screenshot below of the atwork-view.
![alt text](https://github.com/Youbotfontysatwork/youbot_fontys/blob/master/atwork_refbox_ros_client/loggingg.png)

## Referee box client Inventory Sender:

The referee box client inventory sender subcribes to two topics the task_info and the inventory to gather information on the location of the objects and the object itself. The structure of the code is a such, 2 void callbacks from the two nodes and a main loop declaring the subscribers and publishers.

In both callback loops, the code makes the information printed on the terminal it is launched on. In comments the number code used by the referee box is shown, for the user to know the
 meaning of the number identifying the type of object or location. Then the scrip publishes the relevant data as standard strings for the youbot further data treatment. Finally the main loop declares all the components for ROS to interprete the node as a suscriber/publisher. Down below is the data got while listening to the topic that the inventory sender publishes.
![alt text](https://github.com/Youbotfontysatwork/youbot_fontys/blob/master/atwork_refbox_ros_client/source.png)

## Referee box task sender:

The main function of the task_sender can be explained as such: the script sends the robot to which positions, coordinates, it has to drive to. Then the nodes of the global and local path planning are set in action. In order to provide this information task sending node is a subscriber from the topic /robot_example_ros/task_info where the type of data is a atwork_ros_msgs::TaskInfo, one of the types declared for the competition. The positions in the competition are recognised with a code. Two integers define a location: one for the type of location (work station, way point, conveyor belt, prescision table or shelf), and one for the number of the location. The description of this recognition method is set in the code as comment. 

Furthemore this code is also made as a publisher and publishes on another topic: /goal_queue_goals. The type of data that it publishes is a vector pose array where for each position the x and y positions are given as well as the w and z quaternion rotation component. For the script to be able to publish this numerical data, the code uses the ROS parameter function to acquire the coordinates. The coordinates are set as parameter by another script. Those parameters are assigned to variables from the following types: geometry_msgs::Point_<std::allocator<void> >::_x_type, geometry_msgs::Point_ <std::allocator<void> >::_y_type, geometry_msgs::Quaternion_<std::allocator<void> >::_z_type and geometry_msgs::Quaternion_<std::allocator<void> >::_w_type that make up the geometry pose array.

The structure of the code is the following: the code is made up of a main function where the publisher/subcriber is declared following the way in ROS. Further the code has also a void loop where in a first part the parameters are assigned to a variable. Then the code prints the data of the task info topic on the terminal where the code is launched. Afterwards starts a if statement structure to set the coordinates to be published in function of the their type of location. Each if statement goes into cases to determine the specific location. The if statements ends with the possibilitie that no location was found and assignes it to another pose that is in the context of the competition the exit location.

## Further development:

Several improvements will have to be done concerning the communication of the referee box. The task sender code is incomplete for the full working of the competition. The code should be improved in a way that it can read the positions that the robot has to go to no matter whether it is a transportation challenge or a navigation challenge. The current state is that a couple of lines of code have to be manually changed to switch functionality, in the future the choice should be made within the code structure. Furthermore the location coordinates should not only be read from the parameters they should also be saved and exported in a yalm file, and constantly updated.
